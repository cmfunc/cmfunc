# Redis的“两大维度，三大主线”

| 应用维度: |  | 缓存应用 | 集群应用 | 数据结构应用 |
| --- | --- | --- | --- | --- |
| 系统维度: | 处理层<br>内存层<br>存储层<br>网络层 | 线程模型<br>数据结构<br>AOF<br>epoll网络框架 | 主从复制<br>哨兵模式<br> RDB <br> <br>| 数据分片<br> <br> 负载均衡 <br> <br>|
|  |  | 高性能主线 | 高可用主线 | 高可拓展主线 |

## 1. Redis各项关键技术的设计原理

- **高性能：** 线程模型、数据结构、持久化、网络框架；
- **高可靠：** 主从复制、哨兵机制；
- **高可拓展：** 数据分片、负载均衡；

## 2. Redis底层数据结构

Redis使用了一个哈希表来保存所有键值对。一个哈希表，实质是一个数组，数组的每个元素称为一个哈希桶。哈希桶中保存的并不是值本身，而是指向具体值的指针。

哈希表的冲突问题和rehash可能带来的操作阻塞。

Redis解决哈希冲突的方式，是链式哈希。链式哈希，指同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接。

Rehash就是增加现有的哈希桶数量，让逐渐增多的entry元素能在更多的桶之间分散保存，减少单个桶的元素数量。

为了让rehash操作更高效，Redis默认使用了两个全局哈希表：哈希表1和哈希表2。一开始，当刚插入数据时，默认使用哈希表1，此时哈希表2没有被分配空间。随着数量逐渐增多，Redis开始执行rehash，给哈希表2分配更大的空间（是当前哈希表1大小的两倍），把哈希表1中的数据重新映射并拷贝到哈希表2中；释放哈希表1的空间。而哈希表1作为下一次rehash扩容备用。

| 名称 | 时间复杂度 |
| --- | --- |
| 哈希表 | $O(1)$ |
| 跳表 | $O(logN)$ |
| 双向链表 | $O(N)$ |
| 压缩列表 | $O(N)$ |
| 整数数组 | $O(N)$ |

### 2.1 简单动态字符串

### 2.2 双向链表

### 2.3 压缩列表

查看redis中制定key底层的数据结构；

压缩列表本身是一块连续的内存，多大的元素使用多大的内存，一切从实际出发；压缩列表是紧凑存储的，没有多余的空间

```bash
object encoding test_key
```

### 2.4 哈希表

### 2.5 跳表

### 2.6 整数数组

## 3. 高性能IO模型

Redis是单线程，主要是指Redis的网络IO和键值对读写是由一个线程来完成的，也是Redis对外提供键值存储服务的主要流程。

Redis多线程编程模式面临着共享资源的并发访问控制问题。

同步原语;

Redis 采用多路复用机制，使其网络IO操作中能并发处理大量的客户端请求，实现高吞吐率。

### 3.1 网络操作的基本IO模型和潜在阻塞点

socket支持非阻塞模式：
在socket模型中，不同操作调用后会返回不同的套接字类型。socket()方法返回主动套接字，然后调用listen()方法，将主动套接字转化为监听套接字，此时，可以监听来自客户端的连接请求。最后，调用accept()方法接收到达的客户端连接，并返回已连接套接字。

| 调用方法 | 返回套接字类型 | 非阻塞模式 | 效果 |
| :--- | :---: | :---: | ---: |
| socket() | 主动套接字 |  |  |
| listen() | 监听套接字 | 可设置 | accept()非阻塞 |
| accept() | 已连接套接字 | 可设置 | send()/recv()非阻塞 |

针对监听套接字，设置非阻塞模式，当Redis调用accept()但一直未有连接请求到达时，Redis线程可以返回处理其他操作，不用一直等待。

Linux中IO多路复用机制是指一个线程处理多个IO流，select/epoll机制。在Redis只运行在单线程的情况下，该机制允许内核中，同时存在多个监听套接字和已连接套接字。内核会一直监听这些套接字上的连接请求或数据请求。一旦请求到达，就会交给Redis线程处理，这就实现了一个Redis线程处理多个IO流的效果。

select/epoll提供了基于事件的回调机制，即针对不同事件的发生，调用相应的处理函数。select/epoll 一旦监测到FD上有请求到达时，就会触发相应的事件，这些事件会被放进一个事件队列，Redis单线程对该事件队列不断进行处理。这样，Redis无需轮询是否有请求实际发生，避免造成CPU资源浪费。同时Redis在对事件队列中的事件进行处理时，会调用相应的处理函数，这就实现了基于事件的回调。因为Redis一直在对事件队列进行处理，所以能及时响应客户端请求，提升Redis的性能。

## 4. Redis数据持久化

Redis持久化有两大机制：

1. AOF（Append Only File）日志；
1. RDB 快照；

写前日志（Write Ahead Log，WAL），在实际写数据前，先把修改的数据记到日志文件中，以便进行恢复。

AOF：是写后日志，Redis先执行命令，把数据写入内存，然后才记录日志。

传统数据库的日志，redo log（重做日志），记录的是修改后的数据，而AOF里记录的是Redis收到的每一条命令，这些命令以文本形式保存。AOF日志也是在主线程中执行的，如果把日志文件写入磁盘时，磁盘写压力大，就会导致写盘很慢，进而导致后续的操作也无法执行。

