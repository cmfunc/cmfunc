# 常用数据结构与算法

10个数据结构：
数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie树；
10个算法：
递归、排序、二分查找、搜索、哈希算法、贪心算法、回溯算法、分治算法、动态规划、字符串匹配算法

反复迭代、不断沉淀

数组：是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。

## 复杂度量级

常数阶 $O(n)$

## 链表

### 约瑟夫环

``约瑟夫问题``：人们站在一个等待被处决的圈子里。 计数从圆圈中的指定点开始，并沿指定方向围绕圆圈进行。 在跳过指定数量的人之后，处刑下一个人。 对剩下的人重复该过程，从下一个人开始，朝同一方向跳过相同数量的人，直到只剩下一个人，并被释放。

问题即，给定人数、起点、方向和要跳过的数字，选择初始圆圈中的位置以避免被处决。

循环链表：

### 散列表（hash table）

### 回文字符串问题

### 链表反转

### 链表中环检测

### 有序链表合并

### 链表实现优化

### 利用哨兵简化实现难度

边界问题判断和特殊处理

- 如果链表为空时，代码是否能正常工作？
- 如果链表只包含一个节点时，代码是否能正常工作？
- 如果链表只包含两个节点时，代码是否能正常工作？
- 代码逻辑在处理头节点和尾节点时，是否能正常工作？

复杂的算法与数据结构，需要使用举例画图方法，辅助思考；

## 栈

后进者先出，先进者后出；只允许在一端插入和删除数据；

栈可以用数组（顺序栈）或链表（链式栈）来实现；

入栈、出栈；

### 栈在函数调用中的应用

操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构，用来存储函数调用时的临时变量。没进入一个函数，就会将临时变量作为一个栈帧入栈，当被当被调用函数执行完成，返回之后，这个函数对应的栈帧出栈。

C中内存分配：什么时候是分配栈，什么时候分配堆？

## 队列

先进者先出，就是典型的队列；操作受限的线性表数据结构；

入队：放一个数据到队列尾部；
出队：从队列头部取一个元素；

底层系统、框架、中间件的开发；

高性能队列：Disruptor、Linux环形缓存；
公平锁：ArrayBlockingQueue；

顺序队列、链式队列；

### 循环队列

循环队列，长得像一个环。原本数组是有头有尾，是一条直线，现在把数组首位相连，扣成一个环；

做好队列空与队列满的条件；

### 阻塞队列

队列为空时，从队头取数据会被阻塞。因为此时还没数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。

### 并发队列

线程安全的队列，队列的操作多线程安全。基于数组的循环队列，利用CAS原子操作，可以实现非常高效的并发队列。

## 递归

去的过程叫“递”，回来饿过程叫“归”。所有的递归问题，都可以用递归公式来表示。

**满足递归的三个条件：**

1. 一个问题的解可以分解为几个子问题的解；
1. 这个问题与分解后的字问题，出了数据规模不同，求解思路完全一样；
1. 存在递归终止条件；

写递归代码的关键：写出递推公式，找到终止条件。找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。

只要遇到递归，就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。

递归要警惕：堆栈溢出、重复计算、

## 排序

| 排序算法 | 时间复杂度 |
| :--- | ---: |
| 冒泡、插入、选择 | $O(n^2)$ |
| 快排、归并 | $O(nlog(n))$ |
| 桶、计数、基数 | $O(n)$ |

原地排序算法：指空间复杂度是$O(1)$的排序算法。

排序算法的稳定性：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。

### 冒泡排序（Bubble Sort）

冒泡排序的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为$O(1)$，是一个原地排序算法。

冒泡排序算法中，只有交换才可以改变两个元素的前后顺序，冒泡排序算法是稳定的排序算法。

有序度与逆序度；满有序度；

### 插入排序（Insertion Sort）

将数组中的数据分为两个区间，已排序区间和未排序区间。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。

插入排序不需要额外的存储空间，所以空间复杂度为$O(1)$，是一个原地排序算法。

在插入排序中，值相同的元素，可以选择将后面出现的元素，插入到前面出现元素的后面，插入排序是稳定的排序算法。

### 选择排序

选择排序，将区间分为已排序区间和未排序区间，选择排序会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。

选择排序是不稳定的排序算法，因为选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。

### 归并排序

分治思想；如何在$O(n)$时间复杂度内查找一个无序数组中的第K大元素？

原理：先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并起来

分治算法一般是通过递归来实现。分治是一种解决问题的处理思想，递归是一种编程技巧。分析得出递推公式，找到终止条件，最后将递推公式翻译成递归代码。

### 快速排序

快排利用的是分治思想；要排序数组中下标从p到r之间的一组数据，选择p到r之间的任意一个数据作为pivot（分区点）。

遍历p到r之间的数据，将小于pivot的放在左边，将大于pivot的放在右边，将pivot放在中间，数组p到r之间的数据被分成了三个部分，根据分治、递归的处理思想，可以用递归排序下标从p到q-1之间的数据和下标从q+1到r之间的数据，直到区间缩小为1，就说明所有的数据都有序了。

### 桶排序（线性排序）

因为排序算法的时间复杂度是线性的，这类排序算法叫做``线性排序``,之所以能做到线性的时间复杂度，是因为不基于比较的排序算法，不涉及到元素间的比较操作。

核心思想：将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的。

要排序的数据有n个，把他们均匀地划分到m个桶内，每个桶内就有k=n/m个元素。每个桶内部使用快速排序，时间复杂度为$O(k*log(k))$。

桶排序比较适合用在外部排序中。所谓外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。

### 计数排序（线性排序）

基数排序是桶排序的一种特殊情况，当要排序的n个数据，所处的范围并不大的时候，比如最大值是k，我们就可以把数据划分为k个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。

### 基数排序（线性排序）

基数排序，对于要排序的数据，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果a数据的高位比b数据大，那剩下的低位就不用比较了，除此以外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到$O(n)$了。

## 查找算法

### 二分查找（Binary Search）

