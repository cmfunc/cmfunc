一种是基于指针或引用的二叉链式存储法，一种是基于数组的顺序存储法；

堆是一种完全二叉树，最常用数组存储；

二叉树前中后序遍历是一个递归的过程；

写递归代码的关键是看能不能写出递推公式，写递推公式的关键是：如果要解决问题A，就假设子问题B、C已经解决，然后再来看如何利用B、C来解决A。

二叉树遍历的时间复杂度是O(n)

满二叉树：叶子节点全部都在最底层，除了叶子节点之外，每个节点都有左右两个子节点；

完全二叉树：叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其它层的节点个数都要达到最大。

二叉树基于数组的顺序存储法：把根节点存储在下标i=1的位置，左子节点存储在下标2*i=2的位置，右子节点存储在2*i+1=3的位置。以此类推。

二叉树链表使用数组存储方式并不需要像链式存储法那样，存储额外的左右子节点。完全二叉树使用数组进行存储，最节省内存。

二叉查找树最大的特点是，支持动态数据集合的快速插入、删除、查找操作。

散列表快速插入O(1)

二叉查找树要求：在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，其右子树节点的值都大于这个节点的值。
二叉查找树的查找操作：在二叉查找树中查找一个节点。先取根节点，如果等于要查找的数据，直接返回，如果要查找的数据比根节点的值小，就在左子树中递归查找；如果要查找的数据比根节点的值大，就在右子树中递归查找。
二叉查找树插入操作：插入过程类似查找操作，新插入数据一般都在叶子节点，所以需要从根节点开始，依次比较要插入的数据和节点的大小关系。要插入的数据比节点的数据大，而且节点的右子树为空，就将新数据直接插入到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。

二叉查找树的删除操作：针对要删除节点的子节点个数不同，需要分三种情况来处理：
	• 要删除的节点没有子节点，只需要将父节点中指向要删除节点的指针设置为null。
	• 要删除的节点只有一个子节点（只有左子节点或者右子节点），需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点
	• 要删除的节点有两个子节点，需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。（取巧办法，作删除标记）

二叉查找树支持：快速查找最大节点和最小节点、前驱节点和后继节点；中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度O(n)，高效；也称为二叉排序树；

二叉查找树中，如果要存储两个对象键值相同的数据：
	1. 每个节点存储多个数据，通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。
	2. 每个节点仍然只存储一个数据，在查找插入位置过程中，如果碰到一个节点的值，与要插入数据的值相同，就将这个要插入的数据放到这个节点的右子树，把这个新插入的数据当作大于这个节点的值来处理。当要查找数据的时候，遇到值相同的节点时，不停止查找操作，继续在右子树中查找，直到遇到叶子节点才停止。这样把键值等于要查找值的所有节点都找出来。

二叉树查找的时间复杂度：
	1. 退化成链表的链表的二叉树，时间复杂度变成O(n);
	2. 二叉树不管是插入、删除还是查找，时间复杂度跟树的高度成正比，O(height)。

散列表O(1);二叉查找树O(log n);

二叉查找树相对散列表的优势：
	1. 散列表数据是无序的，如果要输出有序的数据，需要先进行排序；对于二叉查找树，只需要中序遍历，就可以在O(n)的时间复杂度内，输出有序的数据序列；
	2. 散列表库扩容耗时很多，遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，在工程中，最常用平衡二叉查找树性能非常稳定，O(logn)。
	3. 哈希冲突的存在，散列表操作的时间复杂度不一定比O(log n)快；还有哈希函数的耗时。
	4. 散列表的构造比二叉查找树复杂，需要考虑的东西多。如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性。

平衡二叉查找树：二叉树中任意一个节点的左右子树的高度相差不能大于1；

红黑树

红黑树中的节点，一类被标记为黑色，一类被标记为红色。除此以外：
	• 根节点是黑色；
	• 每个叶子节点都是黑色的空节点(NIL)，叶子节点不存储数据；
	• 任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；
	• 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；

平衡二叉查找树，是为了解决二叉查找树因为动态更新导致的性能退化问题。“平衡”的意思等价为性能不退化。“近似平衡”等价于性能不会退化得太严重。


完全二叉树：
