# protobuf

## message中的编号

protobuf在传输二进制shu数据时，不会放松数据的key名称和类型，只会记录key所对应的编号和value的二进制，当接收方收到数据化，再通过本地的proto文件生成的语言解码结构或算法，通过编号对应相应的key的名称和类型。

## varint编码

Varint是一种使用一个或多个字节序列化整数的方法，会把整数编码为变长字节。对于32位整型数据经过Varint编码后需要1~5个字节，小的数字使用1个byte，大的数字使用5个bytes。64位整型数据编码后占用1~10个字节。在实际场景中小数字的使用率远远多于大数字，因此通过Varint编码对于大部分场景都可以起到很好的压缩效果。

<https://developers.google.cn/protocol-buffers/docs/encoding>
<https://zhuanlan.zhihu.com/p/84250836>

最高有效位（most significant bit - msb）

## 原码、反码、补码

原码、反码、补码是机器存储一个具体数字的编码方式；

原码：符号加上真值的绝对值；8位二进制
反码：正数的反码是其本身，负数的反码是在其原码基础上，符号位不变，其余各个位取反。（？反码如何识别是负数并对其转换为原码）
补码：正数的补码是其本身；负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后+1。（也即在反码的基础上+1）

反码、补码出现的原因：计算机辨别“符号位”会让计算机的基础电路设计变得十分复杂。利用1+（-1）的原理，将负数和正数直接相加；

## 机器数

一个数在计算机中的二进制表示形式，叫做这个数的机器数；
机器数带符号，计算机中用机器数的最高位存放符号，正数为0，负数为1；
最高位1代表负、0代表正；
带符号的机器数对应的真正数值称为机器数的真值；
