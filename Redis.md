# Redis

| 应用维度: |  | 缓存应用 | 集群应用 | 数据结构应用 |
| --- | --- | --- | --- | --- |
| 系统维度: | 处理层<br>内存层<br>存储层<br>网络层 | 线程模型<br>数据结构<br>AOF<br>epoll网络框架 | 主从复制<br>哨兵模式<br> RDB <br> <br>| 数据分片<br> <br> 负载均衡 <br> <br>|
|  |  | 高性能主线 | 高可用主线 | 高可拓展主线 |

项目中使用redis的原因：性能与并发角度；性能：执行耗时久，结果不频繁变动，运行结果放入缓存；并发：在大并发的情况下，所有请求直接访问数据库，数据库会出现连接异常；

单线程Redis为什么这么快：

1. Redis是单线程工作模型，单线程操作避免频繁的上下文切换；
2. 纯内存操作；
3. 采用非阻塞I/O多路复用机制（redis提供了select、epoll、evport、kqueue多路复用函数库，redis中所有的顶级key都可以设置过期时间）；

## 1. Redis常用数据结构

Redis的底层数据结构：ziplist压缩列表、跳表、双向链表、哈希表、整数数组

Redis使用了一个哈希表来保存所有键值对。一个哈希表，实质是一个数组，数组的每个元素称为一个哈希桶。哈希桶中保存的并不是值本身，而是指向具体值的指针。

哈希表的冲突问题和rehash可能带来的操作阻塞。

Redis解决哈希冲突的方式，是链式哈希。链式哈希，指同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接。

Rehash就是增加现有的哈希桶数量，让逐渐增多的entry元素能在更多的桶之间分散保存，减少单个桶的元素数量。

为了让rehash操作更高效，Redis默认使用了两个全局哈希表：哈希表1和哈希表2。一开始，当刚插入数据时，默认使用哈希表1，此时哈希表2没有被分配空间。随着数量逐渐增多，Redis开始执行rehash，给哈希表2分配更大的空间（是当前哈希表1大小的两倍），把哈希表1中的数据重新映射并拷贝到哈希表2中；释放哈希表1的空间。而哈希表1作为下一次rehash扩容备用。

| 名称 | 时间复杂度 |
| --- | --- |
| 哈希表 | $O(1)$ |
| 跳表 | $O(logN)$ |
| 双向链表 | $O(N)$ |
| 压缩列表 | $O(N)$ |
| 整数数组 | $O(N)$ |

跳表：在有序链表的基础上，逐层给有序链表增加索引。

### 1.1 String

### 1.2 List

list默认使用ziplist，当以下一个条件被满足时，列表转换成linkedlist（双向循环链表）：

1. 向列表中添加一个字符串，且这个字符串的长度超过server.list_max_ziplist_value(默认64)
1. ziplist包含的节点个数超过server.list_max_ziplist_entries(默认512)

### 1.3 Hash

Hash类型设置了用压缩列表保存数据时的两个阈值，一旦超过阈值，Hash类型就会用哈希表来保存数据。

两个阈值对应配置项：
 • Hash-max-ziplist-entries: 表示用压缩列表保存时哈希集合中的最大元素个数。
 • Hash-max-ziplist-value:表示用压缩列表保存时哈希集合中单个元素的最大长度。

压缩列表（键值大小小于64字节）
散列表（键值对个数小于512个）

### 1.4 Set

整数数组使用条件：

1. 集合对象保存的所有元素都是整数值
1. 集合对象保存的元素不超过512个

不满足以上条件的情况下，底层都是哈希表

### 1.5 Zset

### Stream

Redis 5.0新增数据类型

### Bitmap

### HyperLogLog

### GEO

GEO类型的底层数据结构是用Sorted Set实现的。

## 2. 业务

### 2.1 缓存穿透

key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会到数据源，从而可能压垮数据源；比如一个不存在的用户id，无论缓存数据库都不存在；

#### 2.1.1 Redis缓存穿透解决方案

1. 布隆过滤器，将可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截，从而避免对底层存储系统的查询压力；
1. 查询返回的数据为空，空结果进行缓存，过期时间很短，不超过五分钟；

### 2.2 缓存击穿

key对应的数据存在，但在redis中过期，此时若有大量的并发请求过来，发现缓存过期都会从DB加载数据并回设到缓存，大并发的数据可能会瞬间把后端DB压垮；

#### 2.2.1 Redis缓存击穿解决方案

1. 互斥锁

### 2.3 缓存雪崩

当缓存服务器重启或大量缓存集在某个时间失效，失效期间，会给DB带来很大压力；

#### 2.3.1 Redis缓存雪崩解决方案

1. 加锁或队列的方式，保证不会有大量的线程对数据库一次性进行读写；
1. 在原有失效时间上增加随机值，缓存过期时间的重复率会降低；
1. 缓存标记，记录缓存数据是否过期，如果过期触发通知另外的线程在后台更新实际的key缓存；缓存数据的过期时间比缓存标记过期时间延长一倍；

### 2.4 分布式锁

单点：SetNX。通过redis的setnx实现，只有第一次执行的才会成功并返回1，其它情况返回0；释放锁其实只需要把锁的key删除即可，使用del xxx指令。不过，如果在我们执行del之前，服务突然宕机，那么锁就永远无法删除了。所以我们可以通过setex 命令设置过期时间即可。

基于多个Redis节点实现可靠的分布式锁：Redlock

Redlock原理：让客户端和多个独立的Redis实例依次请求加锁，如果客户端能够和半数以上的实例成功完成加锁操作，就认为，客户端成功地获得分布式锁。

## 3 redis高级特性

### 3.1 事务

1. 语法错误，Redis会拒绝执行所有提交的命令操作；返回事务失败；
1. 命令和操作的数据类型不匹配，Redis没有检查出错误，Redis会把可正确执行的命令都执行完，然后报错；
1. 命令入队时就报错，会放弃事务执行，保证原子性；命令入队时没报错，实际执行时报错，不保证原子性；EXEC 命令执行时实例故障，如果开启了 AOF 日志，可以保证原子性。

### 3.2 高性能、高可靠、高可拓展

- 高性能：线程模型、数据结构、持久化、网络框架；
- 高可靠：主从复制、哨兵机制；
- 高可拓展：数据分片、负载均衡；

#### 3.2.1 集群

Redis集群存储原理：
Redis对每一个可以进行hash操作，生成一个[0-16384]的hash值，crc算法后对16384取余，然后将[0-16384]的区间进行拆分，放在不同的redis中。

#### 3.2.2 分布式

分布式高可用集群概念：
通过分布式架构解决性能（高并发）问题；通过集群架构解决故障服务（高可用）问题；
分布式：一个业务分拆为多个子业务，部署在不同的服务器上；

1. 分布式计算：将大量的任务分配到多个计算单元上以提高计算性能；
2. 分布式存储：将大量数据分配到多个单元上以提高总存储量；MySQL的 fbric、mycat；

分布式架构理论上都支持无线水平拓展；

集群：同一个业务，部署在多个服务器上；在多个服务器上部署同一个业务，起到两个作用：

1. 分散每台服务器的压力；
2. 任意一台或几台服务器宕机不会影响到整个系统；

用到分布式架构的基本上都会用到集群，用到集群架构的系统不一定会用到分布式；
Redis高可用方案：Redis Sentinel（哨兵模式）
主从模式，master-slaver，一主多从；监控主从服务器运行情况；提醒；自动故障迁移；
主观下线与客观下线；客观下线只适用于主服务器；
Redis分布式高可用方案：Redis Cluster
主要用途：数据分片，完整的sharding、replication；每个分片只保存一部分数据；hash槽（slot）概念，redis客户端任意访问一个redis实例，如果数据不在该实例中，通过重定向引导客户端访问所需要的redis实例

### 网络

Redis是单线程，主要是指Redis的网络IO和键值对读写是由一个线程来完成的，也是Redis对外提供键值存储服务的主要流程。

Redis 采用多路复用机制，使其网络IO操作中能并发处理大量的客户端请求，实现高吞吐率。

socket支持非阻塞模式：在socket模型中，不同操作调用后会返回不同的套接字类型。socket()方法返回主动套接字，然后调用listen()方法，将主动套接字转化为监听套接字，此时，可以监听来自客户端的连接请求。最后，调用accept()方法接收到达的客户端连接，并返回已连接套接字。

| 调用方法 | 返回套接字类型 | 非阻塞模式 | 效果 |
| :--- | :---: | :---: | ---: |
| socket() | 主动套接字 |  |  |
| listen() | 监听套接字 | 可设置 | accept()非阻塞 |
| accept() | 已连接套接字 | 可设置 | send()/recv()非阻塞 |

针对监听套接字，设置非阻塞模式，当Redis调用accept()但一直未有连接请求到达时，Redis线程可以返回处理其他操作，不用一直等待。

Linux中IO多路复用机制是指一个线程处理多个IO流，select/epoll机制。在Redis只运行在单线程的情况下，该机制允许内核中，同时存在多个监听套接字和已连接套接字。内核会一直监听这些套接字上的连接请求或数据请求。一旦请求到达，就会交给Redis线程处理，这就实现了一个Redis线程处理多个IO流的效果。

select/epoll提供了基于事件的回调机制，即针对不同事件的发生，调用相应的处理函数。select/epoll 一旦监测到FD上有请求到达时，就会触发相应的事件，这些事件会被放进一个事件队列，Redis单线程对该事件队列不断进行处理。这样，Redis无需轮询是否有请求实际发生，避免造成CPU资源浪费。同时Redis在对事件队列中的事件进行处理时，会调用相应的处理函数，这就实现了基于事件的回调。因为Redis一直在对事件队列进行处理，所以能及时响应客户端请求，提升Redis的性能。

### 数据持久化

Redis持久化有两大机制：

1. AOF（Append Only File）日志，持久化记录服务期执行的所有写操作命令，并在服务器启动时，重新执行这些命令来还原数据集；
2. RDB 快照，在指定时间间隔内生成数据集的时间点快照；

AOF 文件的体积通常要大于 RDB 文件的体积，同步慢，会因为部分命令的bug导致整个aof命令重新载入；
RDB每次保存时，会fork出一个子进程，数据集庞大时，fork()会非常耗时；

写前日志（Write Ahead Log，WAL），在实际写数据前，先把修改的数据记到日志文件中，以便进行恢复。

AOF：是写后日志，Redis先执行命令，把数据写入内存，然后才记录日志。

传统数据库的日志，redo log（重做日志），记录的是修改后的数据，而AOF里记录的是Redis收到的每一条命令，这些命令以文本形式保存。AOF日志也是在主线程中执行的，如果把日志文件写入磁盘时，磁盘写压力大，就会导致写盘很慢，进而导致后续的操作也无法执行。

### Redis使用的四个问题

1. Redis缓存和数据库双写一致性问题；
2. Redis缓存的并发竞争问题；
3. 缓存雪崩问题；
4. 缓存击穿问题；

#### Redis与数据库双写一致性问题

一致性问题可分为：最终一致性和强一致性；
如果对数据有强一致性要求，不能放缓存；只能保证最终一致性，从根本上说只能降低不一致性发生的概率，无法完全避免；
正确的更新策略：先更新数据库，再删缓存，删除缓存失败，提供补偿措施，利用消息队列；

#### Redis并发竞争key问题

问题描述：同时多个子系统去set一个key；redis集群环境，数据做了分片操作；
解决方案：分布式锁；

### 内存淘汰策略

#### Redis过期策略

定期删除+惰性删除
定期删除：定期随机抽取key进行检查；
惰性删除：获取某个key时，会检查key是否设置了过期时间，是否过期了；

#### Redis内存淘汰策略

maxmemory-policy volatile-lru：

1. noeviction：内存不足，新写入数据直接报错；
2. allkeys-lru：异常最近最少使用的key；
3. allkeys-random：随机删除某个key；
4. volatile-lru：在设置了过期时间的键空间中，移除最近最少使用的key；
5. volatile-random：在设置了过期时间的键空间中，随机移除某个key；
6. volatile-ttl：在设置了过期时间的键空间中，有更早过期时间的key有限移除；
