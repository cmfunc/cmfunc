# Algorithm

## 常用数据结构与算法

10个数据结构：
数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie树；
10个算法：
递归、排序、二分查找、搜索、哈希算法、贪心算法、回溯算法、分治算法、动态规划、字符串匹配算法

反复迭代、不断沉淀

数组：是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。

### 复杂度量级

常数阶 $O(n)$

## 链表

### 约瑟夫环

``约瑟夫问题``：人们站在一个等待被处决的圈子里。 计数从圆圈中的指定点开始，并沿指定方向围绕圆圈进行。 在跳过指定数量的人之后，处刑下一个人。 对剩下的人重复该过程，从下一个人开始，朝同一方向跳过相同数量的人，直到只剩下一个人，并被释放。

问题即，给定人数、起点、方向和要跳过的数字，选择初始圆圈中的位置以避免被处决。

循环链表：

### 散列表（hash table）

散列表利用数组支持按照随机访问数据的特性，散列表是数组的一种拓展，由数组演化而来。

key经过哈希后的值，与数组下标形成映射关系；

散列函数、哈希函数


#### 哈希算法

将任意长度的二进制值串映射为固定长度的二进制值穿，映射规则称为哈希算法。
映射之后得到的值称为哈希值。

 1. 哈希值不能反向推导出原始数据（单向哈希算法）；
 2. 对输入数据非常敏感，哪怕原始数据只修改了一个Bit，最后得到的哈希值也大不相同；
 3. 散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率很小；
 4. 哈希算法的执行效率尽量高效，针对较长文本，也能快速计算出哈希值；

哈希算法的应用：

 1. 安全加密
 2. 唯一标识
 3. 数据校验
 4. 散列函数
 5. 负债均衡
 6. 数据分片
 7. 分布式存储

#### 业界著名散列算法

MD5、SHA、CRC 哈希算法
散列冲突

>散列冲突解决办法：

1. 开放寻址法：出现哈希冲突，就重新探测（线性探测、二次探测:探测下标的步长变为二次方、双重散列：一组散列函数依次执行直到找到为空的位置）一个空闲位置，将其插入。装载因子。
2. 链表法：在散列表中，每个“桶”或“槽”会对应一条链表，所有散列值相同的元素我们都放在相同槽位对应的链表中。

为了保证散列表的操作效率，一般情况下会尽可能保证散列表中有一定比例的空闲槽位，用``装载因子``来表示空位的多少。

$ 装载因子 = 填入表中的元素个数 / 散列表的长度 $

散列表的查询效率跟散列函数、装载因子、散列冲突都有关系。



### 回文字符串问题

### 链表反转

### 链表中环检测

### 有序链表合并

### 链表实现优化

### 利用哨兵简化实现难度

边界问题判断和特殊处理

- 如果链表为空时，代码是否能正常工作？
- 如果链表只包含一个节点时，代码是否能正常工作？
- 如果链表只包含两个节点时，代码是否能正常工作？
- 代码逻辑在处理头节点和尾节点时，是否能正常工作？

复杂的算法与数据结构，需要使用举例画图方法，辅助思考；

## 栈

后进者先出，先进者后出；只允许在一端插入和删除数据；

栈可以用数组（顺序栈）或链表（链式栈）来实现；

入栈、出栈；

### 栈在函数调用中的应用

操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构，用来存储函数调用时的临时变量。没进入一个函数，就会将临时变量作为一个栈帧入栈，当被当被调用函数执行完成，返回之后，这个函数对应的栈帧出栈。

C中内存分配：什么时候是分配栈，什么时候分配堆？

## 队列

先进者先出，就是典型的队列；操作受限的线性表数据结构；

入队：放一个数据到队列尾部；
出队：从队列头部取一个元素；

底层系统、框架、中间件的开发；

高性能队列：Disruptor、Linux环形缓存；
公平锁：ArrayBlockingQueue；

顺序队列、链式队列；

### 循环队列

循环队列，长得像一个环。原本数组是有头有尾，是一条直线，现在把数组首位相连，扣成一个环；

做好队列空与队列满的条件；

### 阻塞队列

队列为空时，从队头取数据会被阻塞。因为此时还没数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。

### 并发队列

线程安全的队列，队列的操作多线程安全。基于数组的循环队列，利用CAS原子操作，可以实现非常高效的并发队列。

## 树

父节点、子节点、兄弟节点、叶子节点、叶节点

节点的高度、深度、层；

节点的高度：节点到叶子节点的最长路径（边数）

节点的深度：根节点到这个节点所经历的边的个数

节点的层数：节点的深度+1

树的高度``=``根节点的高度；

### 二叉树

二叉树定义：每个节点最多有两个“叉”，也就是两个子节点，分别是左子节点和右子节点。二叉树不要求每个节点都有两个子节点，有的节点只有左子节点，有的节点只有右子节点，有的节点只有右节点。

满二叉树：叶子节点全部都在最底层，除了叶子节点之外，每个节点都有左右两个子节点；

完全二叉树：叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其它层的节点个数都要达到最大。

一种是基于指针或引用的二叉链式存储法，一种是基于数组的顺序存储法；

**堆是一种完全二叉树，最常用数组存储；**

#### 二叉树遍历

前序遍历：对于树中任意节点，先打印这个节点，然后在打印左子树，最后打印右子树；

中序遍历：对于树中任意节点，先打印它的左子树，再打印它本身，最后打印它的右子树；

后序遍历：对于树中任意节点，先打印它的左子树，再打印它的右子树，最后打印它本身；

所以前序、中序、后序遍历是针对节点与其左右子树的打印顺序来说的。

二叉树前中后序遍历是一个递归的过程；写递归代码的关键是看能不能写出递推公式，写递推公式的关键是：如果要解决问题A，就假设子问题B、C已经解决，然后再来看如何利用B、C来解决A。

二叉树遍历的时间复杂度是O(n)

二叉树基于数组的顺序存储法：把根节点存储在下标i=1的位置，左子节点存储在下标2*i=2的位置，右子节点存储在2*i+1=3的位置。以此类推。

二叉树链表使用数组存储方式并不需要像链式存储法那样，存储额外的左右子节点。完全二叉树使用数组进行存储，最节省内存。

### 二叉查找树（二叉搜索树）

二叉查找树最大的特点是，支持动态数据集合的快速插入、删除、查找操作。

散列表快速插入O(1)

二叉查找树要求：在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，其右子树节点的值都大于这个节点的值。

二叉查找树的查找操作：在二叉查找树中查找一个节点。先取根节点，如果等于要查找的数据，直接返回，如果要查找的数据比根节点的值小，就在左子树中递归查找；如果要查找的数据比根节点的值大，就在右子树中递归查找。

二叉查找树插入操作：插入过程类似查找操作，新插入数据一般都在叶子节点，所以需要从根节点开始，依次比较要插入的数据和节点的大小关系。要插入的数据比节点的数据大，而且节点的右子树为空，就将新数据直接插入到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。

二叉查找树的删除操作：针对要删除节点的子节点个数不同，需要分三种情况来处理：
 • 要删除的节点没有子节点，只需要将父节点中指向要删除节点的指针设置为null。
 • 要删除的节点只有一个子节点（只有左子节点或者右子节点），需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点
 • 要删除的节点有两个子节点，需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。（取巧办法，作删除标记）

二叉查找树支持：快速查找最大节点和最小节点、前驱节点和后继节点；

中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度O(n)，高效；也称为二叉排序树；

二叉查找树中，如果要存储两个对象键值相同的数据：

 1. 每个节点存储多个数据，通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。
 2. 每个节点仍然只存储一个数据，在查找插入位置过程中，如果碰到一个节点的值，与要插入数据的值相同，就将这个要插入的数据放到这个节点的右子树，把这个新插入的数据当作大于这个节点的值来处理。当要查找数据的时候，遇到值相同的节点时，不停止查找操作，继续在右子树中查找，直到遇到叶子节点才停止。这样把键值等于要查找值的所有节点都找出来。

二叉树查找的时间复杂度：

 1. 退化成链表的链表的二叉树，时间复杂度变成O(n);
 2. 二叉树不管是插入、删除还是查找，时间复杂度跟树的高度成正比，O(height)。

散列表O(1);二叉查找树O(log n);

二叉查找树相对散列表的优势：

 1. 散列表数据是无序的，如果要输出有序的数据，需要先进行排序；对于二叉查找树，只需要中序遍历，就可以在O(n)的时间复杂度内，输出有序的数据序列；
 2. 散列表库扩容耗时很多，遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，在工程中，最常用平衡二叉查找树性能非常稳定，O(logn)。
 3. 哈希冲突的存在，散列表操作的时间复杂度不一定比O(log n)快；还有哈希函数的耗时。
 4. 散列表的构造比二叉查找树复杂，需要考虑的东西多。如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性。

平衡二叉查找树：二叉树中任意一个节点的左右子树的高度相差不能大于1；

### 平衡二叉查找树

平衡二叉查找树：二叉树中任意一个节点的左右子树的高度相差不能大于1。完全二叉树、满二叉树都是平衡二叉树。

平衡二叉查找树，是为了解决二叉查找树因为动态更新导致的性能退化问题。“平衡”的意思等价为性能不退化。“近似平衡”等价于性能不会退化得太严重。

平衡二叉查找树中“平衡”的意思，其实就是让整棵树左右看起来比较“对称”、比较“平衡”，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些。

### 红黑树

红黑树是平衡二叉查找树；

红黑树中的节点，一类被标记为黑色，一类被标记为红色。除此以外：
 • 根节点是黑色；
 • 每个叶子节点都是黑色的空节点(NIL)，叶子节点不存储数据；
 • 任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；
 • 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；

完全二叉树：

### 字典树

Trie树本质是，利用字符串之间的公共前缀，将重复的前缀合并在一起。

## 堆

堆是一种特殊的树；

堆排序是一种原地、时间复杂度为O(nlogn)的排序算法；

 · 堆是一个完全二叉树；
 · 堆中每个节点的值都必须大于等于（或小于等于）其子树中每个节点的值；

完全二叉树适合用数组来存储，节省空间、不用存储左右指针，通过数组下标查找子节点与父节点；

## 图

什么是非线性数据结构？<br>
线性结构是一个有序数据元素的集合；
常用的线性结构有：线性表、栈、队列、双队列、一维数组；

什么是线性数据结构？<br>

图中的元素叫做``顶点``，图中的顶点可以与任意其他顶点建立连接关系，这种建立的关系叫做``边``。

跟顶点相连的边的条数，叫做顶点的``度``。

边带有方向的图，叫做``“有向图”``。

把边没有方向的图叫做``无向图``。

``入度``：有多少条边指向这个顶点；
``出度``：有多少边以这个顶点为起点指向其他顶点。

``带权图``：每条边都有一个权重。

### 图的存储方法

#### 邻接矩阵

底层是一个二维数组；利用数组元素下标的i,j来表示途中顶点之间的边的方向；有指向就表示是1，无方向表示就是0；

基于数组，获取两个顶点的关系时，非常高效。
基于邻接矩阵存储图的另外一个好处是方便计算。用邻接矩阵存储图的，可以将很多图的运算转换为矩阵之间的运算。

##### Floyd-Warshall算法

#### 邻接表

每个顶点对应一条链表，链表中存储的是与这个顶点相连接的其他顶点。每个顶点对应的链表里，存储的是指向的顶点

#### 图相关“搜索”算法

##### 广度优先搜索（BFS Breadth-First-Search）

“地毯式”层层推进的搜索策略，即先查找离其实顶点最近的，然后是次近的，依次往外搜索。

##### 深度优先搜索（DFS）

算法思想：回溯思想；


## 递归

去的过程叫“递”，回来饿过程叫“归”。所有的递归问题，都可以用递归公式来表示。

递归思想：将大问题分解为小问题来求解，然后将小问题分解为小小问题，一层一层分解，直到问题的数据规模被分解得足够小，不用继续递归分解为止。把一层一层的分解过程画成图，就是一棵树，这棵树就叫递归树。归并排序递归树是一棵满二叉树。

分治算法是一种处理问题的思想，递归是一种编程技巧；

分治算法的递归实现中，每一层递归都会涉及三个操作：

 1. 分解：将原问题分解为一系列子问题；
 2. 解决：递归求解各个子问题，若子问题足够小，则直接求解；
合并：将子问题的结果合并成原问题；


**满足递归的三个条件：**

1. 一个问题的解可以分解为几个子问题的解；
1. 这个问题与分解后的字问题，出了数据规模不同，求解思路完全一样；
1. 存在递归终止条件；

写递归代码的关键：写出递推公式，找到终止条件。找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。

只要遇到递归，就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。

递归要警惕：堆栈溢出、重复计算、

## 排序

| 排序算法 | 时间复杂度 |
| :--- | ---: |
| 冒泡、插入、选择 | $O(n^2)$ |
| 快排、归并 | $O(nlog(n))$ |
| 桶、计数、基数 | $O(n)$ |

原地排序算法：指空间复杂度是$O(1)$的排序算法。

排序算法的稳定性：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。

### 冒泡排序（Bubble Sort）

冒泡排序的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为$O(1)$，是一个原地排序算法。

冒泡排序算法中，只有交换才可以改变两个元素的前后顺序，冒泡排序算法是稳定的排序算法。

有序度与逆序度；满有序度；

### 插入排序（Insertion Sort）

将数组中的数据分为两个区间，已排序区间和未排序区间。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。

插入排序不需要额外的存储空间，所以空间复杂度为$O(1)$，是一个原地排序算法。

在插入排序中，值相同的元素，可以选择将后面出现的元素，插入到前面出现元素的后面，插入排序是稳定的排序算法。

### 选择排序

选择排序，将区间分为已排序区间和未排序区间，选择排序会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。

选择排序是不稳定的排序算法，因为选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。

### 归并排序

分治思想；如何在$O(n)$时间复杂度内查找一个无序数组中的第K大元素？

原理：先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并起来

分治算法一般是通过递归来实现。分治是一种解决问题的处理思想，递归是一种编程技巧。分析得出递推公式，找到终止条件，最后将递推公式翻译成递归代码。

### 快速排序

快排利用的是分治思想；要排序数组中下标从p到r之间的一组数据，选择p到r之间的任意一个数据作为pivot（分区点）。

遍历p到r之间的数据，将小于pivot的放在左边，将大于pivot的放在右边，将pivot放在中间，数组p到r之间的数据被分成了三个部分，根据分治、递归的处理思想，可以用递归排序下标从p到q-1之间的数据和下标从q+1到r之间的数据，直到区间缩小为1，就说明所有的数据都有序了。

### 桶排序（线性排序）

因为排序算法的时间复杂度是线性的，这类排序算法叫做``线性排序``,之所以能做到线性的时间复杂度，是因为不基于比较的排序算法，不涉及到元素间的比较操作。

核心思想：将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的。

要排序的数据有n个，把他们均匀地划分到m个桶内，每个桶内就有k=n/m个元素。每个桶内部使用快速排序，时间复杂度为$O(k*log(k))$。

桶排序比较适合用在外部排序中。所谓外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。

### 计数排序（线性排序）

基数排序是桶排序的一种特殊情况，当要排序的n个数据，所处的范围并不大的时候，比如最大值是k，我们就可以把数据划分为k个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。

### 基数排序（线性排序）

基数排序，对于要排序的数据，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果a数据的高位比b数据大，那剩下的低位就不用比较了，除此以外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到$O(n)$了。

## 查找算法

### 二分查找（Binary Search）

## 字符串匹配算法

Java的indexOf()、Python的find()

### BF算法

### RK算法

### BM算法

### KMP算法


## 动态规划

适合求解最优问题

将最优解问题，分解为多个阶段求解，逐级推导；

最优子结构
无后效性
重复子问题

一个模型：
动态规划适合解决的问题的模型，多阶段决策最优解模型；每个决策阶段都对应一组状态，寻找一组决策序列，经过这组决策序列，产生最终期望求解的最优值。
三个特征：

 1. 最优子结构
 问题的最优解包含子问题的最优解；
 2. 无后效性
 推导后面的阶段时，只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的；
 某阶段状态一旦确定，就不受之后阶段的决策影响
 3. 不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态；

动态规划解题思路：

 1. 状态转移表法
 2. 状态转移方程法

状态转移方程是解决动态规划问题的关键；

莱温斯坦距离

## 数据分析算法

### 决策树

### 朴素贝叶斯

### SVM

### KNN

### K-Means

### EM聚类

### 关联规则挖掘

### PageRank

### AdaBoost
