# Python

## 多进程

Unix/Linux操作系统提供了一个fork()系统调用，它非常特殊。普通的函数调用，调用一次，返回一次，但是fork()调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。
子进程永远返回0，而父进程返回子进程的ID。这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID。有了fork调用，一个进程在接到新任务时就可以复制出一个子进程来处理新任务，常见的Apache服务器就是由父进程监听端口，每当有新的http请求时，就fork出子进程来处理新的http请求。
创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start()方法启动，这样创建进程比fork()还要简单。join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。
如果要启动大量的子进程，可以用进程池的方式批量创建子进程。multiprocessing 。
很多时候，子进程并不是自身，而是一个外部进程。我们创建了子进程后，还需要控制子进程的输入和输出。
Process之间肯定是需要通信的，操作系统提供了很多机制来实现进程间的通信。Python的multiprocessing模块包装了底层的机制，提供了Queue、Pipes等多种方式来交换数据。

subprocess模块可以让我们非常方便地启动一个子进程，然后控制其输入和输出。

来自 <https://www.liaoxuefeng.com/wiki/1016959663602400/1017628290184064>

## 多线程

多任务可以由多进程完成，也可以由一个进程内的多线程完成。

我们前面提到了进程是由若干线程组成的，一个进程至少有一个线程。

由于线程是操作系统直接支持的执行单元，因此，高级语言通常都内置多线程的支持，Python也不例外，并且，Python的线程是真正的Posix Thread，而不是模拟出来的线程。

Python的标准库提供了两个模块：_thread和threading，_thread是低级模块，threading是高级模块，对_thread进行了封装。绝大多数情况下，我们只需要使用threading这个高级模块。

多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。

因为Python的线程虽然是真正的线程，但解释器执行代码时，有一个GIL锁：Global Interpreter Lock，任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。

所以，在Python中，可以使用多线程，但不要指望能有效利用多核。如果一定要通过多线程利用多核，那只能通过C扩展来实现，不过这样就失去了Python简单易用的特点。

## 多协程

协程不是函数调用，协程返回的对象不是简单的值。

协程的切换不需要锁机制，因为不存在并发或并行的写变量。协程知识控制了函数调用的中断，只是打乱了函数调用执行的顺序，并不会出现并行的情况，可能会出现并发。所以在使用协程时，要小心，如果协程没有被转化为任务，调度到多线程上并发的执行，那么只要协程内有一个阻塞的地方，整个协程就会阻塞。

Python的GIL保证线程的并发安全。

Python的协程通过generator实现，generator可通过for循环迭代，可以不断调用next()函数获取由yield语句返回的下一个值。Python的yield不仅可以返回值，还可以接收调用者发出的参数。

Python通过协程的send与yield表达式来控制整个执行流程的中断与再执行。通过协程的close方法来关闭协程。

协程由一个线程执行时，可以无锁执行，函数间协作式完成任务，不是多线程的抢占式执行。
