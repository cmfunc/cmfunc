# 垃圾回收

垃圾回收，一种自动内存管理的机制。当程序向操作系统申请的内存不再需要时，垃圾回收主动将其回收供其他代码进行内存申请时候复用，或者将其归还给操作系统，这种针对内存级别资源的自动回收过程，称为垃圾回收。

负责垃圾回收的程序组件，即为垃圾回收器。

程序需要进行特殊优化时，通过提供可调控的API，对gc的运行时机、运行开销进行把控。

垃圾回收器的执行过程被划分为两个半独立的组件：

 1. 赋值器：用户态的代码，只是在修改对象之间的引用关系，也就是在对象图（对象之间引用关系的一个有向图）进行操作。
 2. 回收器：负责执行垃圾回收的代码。

根对象：在垃圾回收术语中叫做根集合，是垃圾回收器在标记过程时最先检查的对象，包括：

 1. 全局变量：程序在编译期就能明确的那些存在于程序整个生命周期的变量。
 2. 执行栈：每个goroutine都包含自己的执行栈，包含栈上的变量及指向分配的堆内存区块的指针。
 3. 寄存器：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块。

常见gc实现方式：

 1. 追踪（tracing）：从根对象出发，根据对象之间的引用信息，一步步推进直到扫描完毕整个堆并确定需要保留的对象，从而回收所有可回收的对象。Go、Java、V8的实现均为追踪式GC。
 2. 引用计数（reference counting）：每个对象自身包含一个被引用的计数器，当计数器归零时自动得到回收。该方法缺陷较多，追求高性能时通常不被采用。Python、Objective-C为引用计数式GC。

追踪式：
 • 标记清扫：从根对象出发，将确定存活的对象进行标记，并清扫可以回收的对象。
 • 标记整理：为了解决内存碎片问题提出，在标记过程中，将对象尽可能整理到一块连续的内存上。
 • 增量式：将标记与清扫的过程分批执行，每次执行很小的部分，从而增量的推进垃圾回收，达到近似实时、几乎无停顿的目的。
 • 增量整理：在增量式的基础上，增加对对象的整理过程。
 • 分代式：将对象根据存活时间的长短进行分类，存活时间小于某个值的年轻代，存活时间大于某个值的为老年代，永远不会参与回收的对象为永久代。并根据分代假设（如果一个对象存活时间不长泽倾向于被回收，如果一个对象已经存活很长时间则倾向于存活更长时间）对对象进行回收。

引用计数：
根据对象自身的引用计数来回收，当引用计数归零时立即回收。

Go的GC目前使用的是无分代（对象没有代际之分）、不整理（回收过程中不对对象进行移动与整理）、并发（与用户代码并发执行）的三色标记清扫算法。

选择三色标记的原因：

 1. 对象整理的优势是解决内存碎片问题以及“允许”使用顺序内存分配器。Go运行时的分配算法基于tcmalloc，基本上没有碎片问题。并且顺序内存分配器在多线程的场景下并不使用。go使用基于tcmalloc的现代内存分配算法，对对象进行整理不会带来实质性的性能提升。
 2. 分代GC依赖分代假设，即GC将主要的回收目标放在新创建的对象上（存活时间短，更倾向于被回收），而非频繁检查所有对象。Go的编译器会通过逃逸分析将大部分新生对象存储在栈上（栈直接被回收），只有那些需要长期存在的对象才会被分配到需要进行垃圾回收的堆中。分代GC回收的那些存活时间短的对象在Go中是直接被分配到栈上，当goroutine死亡后，栈会被直接回收，不需要GC的参与，所以分代假设并没有带来直接优势。  Go的垃圾回收器与用户代码并发执行，使得STW的时间与对象的代际、对象的size没有关系。Go团队更关注如何更好地让GC与用户代码并发执行（使用适当的CPU来执行垃圾回收），而非减少停顿时间上。

三色标记

核心：对象的三色抽象以及波面（wavefront）推进。
三色抽象是一种描述追踪式回收器的方法，标记清扫的垃圾回收。

三色抽象规定三种不同类型的对象：
 • 白色对象（可能死亡）：未被回收器访问到的对象。在回收开始阶段，所有对象均为白色，当回收结束后，白色对象不可达。
 • 灰色对象（波面）：已被回收器访问到的对象，但回收器需要对其中的一个或多个指针进行扫描，因为他们可能还指向白色对象。
 • 黑色对象（确定存活）：已被回收器访问到的对象，其中所有字段都已被扫描，黑色对象中任何一个指针都不可能直接指向白色对象。

垃圾回收开始时，只有白色对象。随着标记过程开始进行，灰色对象开始出现（着色），这时候波面便开始扩大。当一个对象所有子节点均完成扫描时，会被着色为黑色。当整个堆遍历完成时，只剩下黑色和白色对象，这时的黑色对象为可达对象，即存活；白色对象为不可达对象，即死亡。过程中，将灰色对象视为波面，将黑色对象和白色对象分离，使波面不断向前推进，直到所有可达的灰色对象都变为黑色对象为止的过程。

STW

Stw在垃圾回收过程中为了保证实现的正确性、防止无止境的内存增长等问题而不可避免的需要停止赋值器进一步操作对象图的一段过程。

Stw已被优化到半毫秒级别以下。

Runtime.GC()，需要通知并让所有用户态代码停止，但for{}所在goroutine永远不会被中断，从而始终无法进入STW阶段。Go1.14后，这些goroutine会被异步的抢占。

内存泄漏
预期的能很快被释放的内存由于附着在长期存活的内存上、或生命周期意外地被延长，导致预计能够立即回收的内存而长时间得不到回收。
 • 预期能被快速释放的内存因被根对象引用而没有得到迅速释放；
 • Goroutine泄漏：goroutine需要维护执行用户代码的上下文信息，如果程序不断产生新的goroutine、且不结束已经创建的goroutine并复用这部分内存，会造成内存泄漏。
 • Channel 作为一种同步原语，会连接两个不同的 goroutine，如果一个 goroutine 尝试向一个没有接收方的无缓冲 channel 发送消息，则该 goroutine 会被永久的休眠，整个 goroutine 及其执行栈都得不到释放

如何保证标记与清除过程的正确性？

写屏障：
三色标记算法的强弱不变形和赋值器的颜色；写屏障是在并发垃圾回收器中出现的概念，垃圾回收器的正确性体现，不应出现对象的丢失，也不应错误的回收还不需要回收的对象。

为了保证强弱三色不变性的并发指针更新操作，需要通过赋值器屏障技术来保证指针的读写操作一致性。
Go中的写屏障、混合写屏障，其实是指赋值器的写屏障，赋值器的写屏障作为一种同步机制，使赋值器在进行指针写操作时，能够“通知”回收器，进而不破坏弱三色不变性。
Dijkstra插入屏障、Yuasa删除屏障。

触发GC的时机：

 1. 主动触发，通过调用 runtime.GC 来触发 GC，此调用阻塞式地等待当前 GC 运行完毕。
 2. 被动触发，分为两种方式：
  ○ 使用系统监控，当超过两分钟没有产生任何 GC 时，强制触发 GC。
  ○ 使用步调（Pacing）算法，其核心思想是控制内存增长的比例。
GC 调优时，通常是指减少用户代码对 GC 产生的压力，这一方面包含了减少用户代码分配内存的数量（即对程序的代码行为进行调优），另一方面包含了最小化 Go 的 GC 对 CPU 的使用率（即调整 GOGC）。
