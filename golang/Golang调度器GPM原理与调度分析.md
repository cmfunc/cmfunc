# GPM 调度器

[刘丹冰博客](<https://www.jianshu.com/p/fa696563c38a>)

## 1. 调度器的由来

CPU调度器、时间片、进程；

CPU调度切换的是进程和线程，多线程开发设计要考虑同步竞争、锁等问题；

进程虚拟内存会占用4GB[32位操作系统],线程大约4MB；

线程分为“内核态”线程和“用户态”线程；一个“用户态线程”必须绑定一个“内核态线程”，CPU并不知道“用户态线程”的存在，CPU只知道它运行的是一个“内核态线程”（Linux的PCB进程控制块）。

多个goroutine绑定一个或多个线程（thread）上。

goroutine与系统线程是M:N的关系。线程由CPU调度是抢占式的，协程由用户态调度是协作式的，一个协程让出CPU后，才执行下一个协程。一个goroutine只占几kb，goroutine栈的大小是可以伸缩的，runtime会自动为goroutine分配，可以在有限的空间内支持大量的goroutine，支持更多的并发。

## 2. GMP模型及设计思想

### 2.1 2012年前的goroutine调度器

G：goroutine协程

M：thread线程

全局goroutine队列；锁；系统线程；

老调度器的缺点：

1. 创建、销毁、调度G都需要每个M获取锁，这就形成了激烈的锁竞争；
1. M转移G会造成延迟和额外的系统负载；
1. 系统调用（CPU在M之间的切换）导致频繁的线程阻塞和取消阻塞操作增加了系统开销；

### 2.2 2012年的GMP

引入了P（Processor），它包含了运行goroutine的资源，如果线程想运行goroutine，必须先获取P，P中还包含了可运行的G队列。

在Go中，线程是运行goroutine的实体，调度器的功能是把可运行的goroutine分配到工作线程上。

```go
GOMAXPROCS
```

1. 全局队列：存放等待运行的G。
1. P的本地队列：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建G‘时，G’优先加入到P的本地队列，如果队列满了，则会把本地队列中的一半移动到全局队列。
1. P列表：所有的P都在程序启动时创建，并保存在数组中，最多有GOMAXPROCS（可配置）个。
1. M：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列拿一批G放在P的本地队列，或从其他P的本地队列偷一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。

Goroutine调度器和OS调度器是通过M结合起来的，每个M都代表了1个内核线程，OS调度器负责把内核线程分配到CPU的核上运行。

P的数量：由启动时环境变量$GOMAXPROCS或者是由runtime的方法GOMAXPROCS决定。这意味着程序执行的任意时刻都只有$GOMAXPROCS个goroutine在同时运行。

M的数量：go语言本身的限制，go程序启动时，会设置M的最大数量，默认10000.但是内核很难支持这么多线程数，所以这个限制可以忽略。runtime/debug中的SetMaxthread函数，设置M的最大数量。一个M阻塞了，会创建新的M。

P何时创建：在确定了P的最大数量n后，运行时系统会根据这个数量创建n个P。

M何时创建：没有足够的M来关联P并运行其中的可运行的G。比如所有的M此时都阻塞住了，而P中还有很多就绪任务，就会去寻找空闲的M，而没有空闲的，就会去创建新的M。

#### 2.2.1 调度器的设计策略

复用线程：避免频繁的创建、销毁线程，而是对线程的复用。

1. work stealing机制：当本线程无可运行的G时，尝试从其他线程绑定的P偷取G，而不是销毁线程。
1. hand off机制：当M因为G进行系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的闲扯给

## 3. 调度场景过程
