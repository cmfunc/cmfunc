http://wen.topgoer.com/docs/golang-design-pattern/golang-design-pattern-1cbgha2ltg796

创建型模式
核心思想是方法单一职责，接口的封装和功能的组合

简单工厂
将结构体首字母小写不可导出

工厂方法
将功能对象生成的方法绑定到子类上，真正的功能方法在积累上；
需要有单独的函数负责调用逻辑；

抽象工厂模式
将一组类实现同一个接口，单独函数可以对实现了该接口的所有对象进行操作

创建者模式
将对象的创建方法与功能方法分开，将创建方法拆分为多个创建方法，并实现接口，然后组合调用多个创建方法，完成对象的创建。

原型模式
原型模式使对象能复制自身，并暴露到接口，使客户端面向接口编程时，不知道接口实际对象的情况下生成新的对象。
原型模式配合原型管理器使用，使客户端在不知道具体类的情况下，通过接口管理器得到新的实例

单例模式
使用懒惰模式的单例模式，使用双重检查加锁保证线程安全

结构型模式

外观模式
? 这是什么意思？门面模式？

适配器模式
适配器模式用于转换一种接口适配另一种接口；
具体方法是，利用构造函数，将原接口类型传入，并作为目标接口类型类的成员。
非入侵式接口特征？

代理模式
代理模式用于延迟处理操作或进行实际操作前后进行其他处理。
类似于装饰器，在真实功能呢函数外，包裹了一层其他条件检查或判断的逻辑。

组合模式
组合模式统一对象和对象集，使用相同接口使用对象和对象集；
组合模式常用于树状结构，统一叶子节点和树节点访问。

享元模式
从对象中剥离出不发生改变且多个实例需要的重复数据，独立出一个享元，使多个对象共享，节省内存及减少对象数量。

装饰模式
使用对象组合的方式动态改变或增加对象行为
使用匿名组合，装饰器中不必显式定义转调原对象方法；
实现方式：结构体工厂方法使用新的结构体（实现了原接口的方法，这个新结构体的方法会调用旧的结构体方法，在这个新的结构体方法中可以对旧的结构体方法进行功能新增）进行包裹。

桥模式
分离抽象部分和实现部分。使两部分独立拓展。
实现方式：将实现部分抽象为结构体的成员，使用工厂方法初始化对象时，将实现部分传入。

行为模式

中介者模式
封装对象之间互交，使依赖变简单，是复杂交互简单化，封装在中介者中。
利用switch封装转换函数。

观察者模式
一个对象的改变会触发其它观察者的相关动作，而此对象无需关心联动对象的具体实现。
实现方式：对象的内部字段有个记录所有观察者的slice，出现数据更新时，就会调用通知方法，通知slice中保存的所有观察者。

命令模式
把某个对象的方法调用封装到对象中，方便传递、存储、调用。
将功能封装成结构体，结构体都实现了同一个接口类型，在调用时可以随意切换功能结构体。

迭代器模式
用于使用相同方式迭代不同类型集合或者隐藏集合类型的具体实现。

模板方法模式
将通用方法和通用步骤放在父类中，把具体实现延迟到子类中时间。

策略模式
定义一系列算法，让这些算法在运行时可以切换，使得分离算法。
开闭原则？
结构体嵌套，对调用方法进行封装。

状态模式
用于分离状态与行为

备忘录模式
保存程序内部状态到外部，不暴露内部实现细节。
实现方式，接口取具体类型。

解释器模式
解释器模式定义一套语言文法，并设计该语言解释器，使用户能使用特定文法控制解释器行为。解释器模式的意义在于，它分离多种复杂功能的实现，每个功能只需关注自身的解释。对于调用者不用关心内部的解释器的工作，只需要用简单的方式组合命令就可以。

职责链模式
分离不同职责，动态组合相关职责

访问者模式
给一系列对象透明的添加功能，把相关代码封装到一个类中。
