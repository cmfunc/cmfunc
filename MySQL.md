# MySQL

## 1. 索引

### 1.2 创建索引

索引的使用是为了加快查询的效率

### 1.3 优化器

选择索引是优化器的工作
优化器选择索引的目的，是确定最优的执行方案，用最小的代价去执行语句。
在数据库中，扫描行数是影响执行代价的因素之一，扫描的行数越少，意味着访问磁盘数据的次数越少，消耗CPU资源越少。以及是否使用临时表、是否排序。

优化器如何判断扫描行数
MySQL在真正执行语句前，是根据统计信息估算记录数。
统计信息就是索引的区分度，一个索引上不同的值越多，这个索引的区分度就越好。一个索引上不同的值的个数，我们称为“基数”。基数越大，索引的区分度越好。

使用show index方法，看到索引的基数

MySQL使用采样统计得到索引基数
因为把整张表取出来一行行统计，可以得到精确的结果，但是代价太高。
采样统计的时候，InnoDB默认会选择N个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，得到这个索引的基数。

存储索引统计的方式，通过innodb_stats_persistent的值来选择：
 • 设置为on，持久化存储。N：20，M：10；
 • 设置为off，只存储内存中。N：8，M：16；

analyze table t命令，用来重新统计索引信息；
force index强行选择索引；

## 2. 数据类型

## 3. 事务、锁和日志

### 3.1 WAL

《孔乙己》粉板与账本；
先写日志，再写磁盘；InnoDB先把记录写到redo log(粉板)里面，并更新内存。

crash-safe
Redo log, InnoDB保证即使数据库发生异常重启

Binlog归档日志，属于server层的日志；所有引擎都可以使用；

Redo log是物理日志，记录的是‘在某个数据页上做了什么修改’；
Bin log是逻辑日志，记录的是这个语句的原始逻辑；
Redo log是循环写的，空间固定会用完；
Binlog是可以追加写入；
追加写是指binlog文件写到一定大小后会切换到下一个，不会覆盖以前的日志；

Redo log写完了，要flush脏页，这种情况下，InnoDB整个系统都不能接受更新。

正确告诉InnoDB所在主机的IO能力，这样InnoDB才能知道需要全力刷脏页的时候，可以刷多快。

innodb_io_capacity参数

innodb_flush_neighbors参数，连坐；机械硬盘开启，SSD设置为0；因SSD中IOPS不是瓶颈，更快地执行完必要的刷脏页操作，减少SQL语句响应时间。

### 3.2 全局锁和表锁

根据加锁范围，MySQL的锁可以分为全局锁、表锁和行锁三类；

全局锁
对整个数据库实例加锁，flush tables with lock；可以使整个库处于只读状态，之后其他线程的以下语句会被阻塞：数据的增删改、数据定义语句、更新类事务的提交语句。

全局锁的使用场景，做全库逻辑备份，即将整个表都select出来存成文本。
备份过程中整个库完全处于只读状态。
 • 如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；
 • 如果在从库上备份，备份期间从库不能执行主库同步过来的binlog，会导致主从延迟；
备份为什么需要加锁：不加锁的话，备份系统备份的得到的库不是一个逻辑时间点，这个视图是逻辑不一致的。官方自带的逻辑备份工具是mysqldump，当mysqldump使用参数-single-transaction的时候，导数据之前会启动一个事务，来确保拿到一致性视图，由于MVCC的支持。这个过程中数据是可以正常更新的。

一致性读的前提是引擎支持这个隔离级别，single-stransaction方法只适用于所有的表使用事务引擎的库。如果有的表使用了不支持事务的引擎，那么备份就只能通过FLWRL方法。

使用FTWRL方式而不是用set global readonly=true的原因：
 • 在有些系统中，readonly的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此修改global变量的方式影响面更大；
 • 异常处理机制上有差异。如果FTWRL后，客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态；readonly会一直保持readonly状态，这样会导致整个库长时间处于不可写状态。
业务的更新不只是增删改查(DML)，还有可能是加字段等修改表结构的操作(DDL)。

表级锁
表级锁有两种：一种是表锁，一种是元数据锁

表锁语法 lock tables … read/write。与FTWRL类似，可以用unlock tables主动释放锁，也可在客户端断开时自动释放；
Lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。

元数据锁meta data lock。不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用是保证读写的正确性。MySQL5.5引入MDL，当对一个表做增删改查操作时，加MDL读锁；当要对表做结构变更时，加MDL写锁。
 • 读锁之间不互斥，因此可以多个线程同时对一张表增删改查；
 • 读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。

MDL锁是系统默认会加的，但是不能忽略；给表加一个字段，导致整个库挂了；
给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据
表上的查询语句频繁，而且客户端有重试机制，也就是超时后会再起一个新session在请求的话，这个库的线程很快就会爆满。

事务中的MDL锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后释放。

如何安全地给小表加字段？
首先要解决长事务，事务不提交，就会一直占着MDL锁。
在MySQL的information_schema库的innodb_trx表中，可以查到当前执行的事务。如果要做DDL变更的表刚好有长事务在执行，要考虑先暂停DDL，或者kill掉这个长事务。
设定等待时间

表锁一般是在数据库引擎不支持行锁的时候才会被用到。如果你发现你的应用程序里有lock tables这样的语句，需要排查：

 1. 你的系统现在还在用MyISAM这类不支持事务的引擎；
 2. 引擎升级但是代码没升级；

MDL会直到事务提交才释放，在做表结构变更的时候，一定要防止锁住线上查询和更新。

### 3.3 行锁

事务A等待事务B的id=2的行锁，事务B等待事务A的id=1的行锁；相互等待。

死锁出现后的策略：

- 直接进入等待，直到超时，这个超时时间可以通过参数innodb_lock_wait_timeout设置；
- 发起死锁检测，发现死锁后，主动回滚死锁链条中的某个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑。

在InnoDB中，innodb_lock_wait_timeout的默认值是50s，意味着如果采用第一个策略，当出现死锁后，第一个被锁住的线程要多50s才会超时退出，其他线程才有可能继续执行。

正常情况下采用主动死锁检测，主动死锁检测在发生死锁的时候，是能够快速发现并进行处理，但是它也是有额外负担。负担表现在，每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现循环等待，也就是死锁。

怎么解决由这种热点行更新导致的性能问题？

问题的症结在于，死锁检测要耗费大量的CPU资源

- 头痛医头，确保这个业务一定不会出现死锁，可临时把死锁检测关掉关掉死锁检测意味着可能出现大量的超时，是业务有损的。
- 控制并发度，并发控制要做在数据库服务端。如果有中间件，可以考虑中间件实现；如果能修改MySQL源码，可以做在MySQL里。基本思路是，对于相同行的更新，在进入引擎之前排队。这样在InnoDB内部就不会有大量的死锁检测工作。

如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁的申请尽量往后放。

但是调整语句顺序，并不能完全避免死锁。减少死锁的主要方向，控制访问相同资源的并发事务量。

### 3.4 事务隔离

MySQL中，有两个“视图”的概念：

- 一个是view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是create view …，而它的查询方法与表一样。
- 另一个是InnoDB在实现MVCC时用到的一致性读视图，即consistent read view，用于支持RC（Read Commintted，读提交）和RR（Repeatable Read，可重复读）隔离级别的实现。

1. 幻读：幻读侧重的方面是某一次的select操作得到的结果所表征的数据状态无法支撑后续的业务操作。select某记录是否存在，不存在，准备插入此记录，但是执行insert时发现此记录已存在，无法插入，此时就产生了幻读。mysql 的幻读并非什么读取两次返回结果集不同，而是事务在插入事先检测不存在的记录时，惊奇的发现这些数据已经存在了，之前的检测读获取到的数据如同鬼影一般。insert属于隐士的读，用于检查主键冲突，不可重复读侧重表达的是读-读，幻读侧重读-写；
2. 脏读：一个事务读到另一个事务没有提交的数据；
3. 不可重复读：事务A执行两次select操作得到不同的数据集，即select1得到10条记录，select2得到11条记录，在R-U、R_C级别下出现；A事务在执行过程中，B事务对数据进行了修改或删除，导致A两次读取的数据不一致；重点在于update和delete（锁行即可解决），

#### 事务的四级隔离级别

| 级别     | symbol           | 描述                                             | 值   | 存在问题                                                     |
| -------- | ---------------- | ------------------------------------------------ | ---- | ------------------------------------------------------------ |
| 读未提交 | READ-UNCOMMITTED | 一个事务还没提交，它做的变更就能被别的事务看到； | 0    | 存在脏读、不可重复读、幻读的问题                             |
| 读已提交 | READ-COMMITTED   | 一个事务提交以后，他做的变更才会被其他事务看到； | 1    | 解决脏读的问题，存在不可重复读、幻读的问题                   |
| 可重复读 | REPEATABLE-READ  |                                                  | 2    | MySQL默认级别，解决脏读、不可重复读的问题，存在幻读的问题。使用MMVC机制 实现可重复读 |
| 序列化   | SERIALIZABLE     |                                                  | 3    | 解决脏读、不可重复读、幻读，可保证事务安全，但完全串行执行，性能最低 |

#### 数据库事务（ACID四大特性）

1. 原子性（atomicity），一个事务内所有操作共同组成一个原子包，要么全部成功，要么全部失败；
2. 一致性（consistency），一致性基于原子性，原子性只保证了一个事务内的所有操作同一性，没有保证同一事务中所有操作同一时刻一起生、一起死；计算指令有先后顺序，决定了一个事务的提交，会经历一个时间过程，数据库事务的一致性规定了事务提交前后，永远只可能存在事务提交前的状态和事务提交以后的状态，从一个一致性的状态到另一个一致性状态，不存在中间的过程态；
3. 隔离性（isolation），隔离性基于原子性和一致性，多个事务以原子包的形式并发的执行，但是每个事务互不干扰；由于多个事务可能操作同一资源，不同的事务为了保证隔离性，会有很多锁方案；
4. 持久性（durability），当一个事务提交以后，数据库的状态永远的发生了改变；

#### 可重复读

在可重复读隔离级别下，事务在启动的时候就“拍了个快照”。这个快照是基于整库的。

快照的实现: InnoDB里每个事务有一个唯一的事务ID，叫作transaction id。它是在事务开始的时候向InnoDB的事务系统申请，是按申请顺序严格递增。而每行数据也都是有多个版本。每次事务更新数据的时候，都会生成一个新的数据版本，并且把transaction id赋值给这个数据版本的事务ID，记为row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。数据表中的一行记录，其实可能有多个版本(row)，每个版本有自己的row trx_id。

一个事务只需要在启动的时候声明说，“以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，就认；如果是我启动以后才生成的，我就不认，我必须要找到它的上一个版本”。如果上一个版本也不可见，就继续往前找；如果是这个事务自己更新的数据，也认。

InnoDB为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”（指启动了但未提交）的所有事务ID。数组里面事务ID的最小值记为低水位，当前系统里面已经创建过的事务ID的最大值加1记为高水位。这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。数据版本的可见性规则，基于数据的row trx_id和这个一致性视图的对比结果得到的。InnoDB利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。

可重复读的核心就是一致性读；事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。
