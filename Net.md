# 通过网络传输结构化的数据

想要使用网络框架的API来传输结构化的数据，必须得先实现结构化的数据与字节流之间的双向转换。

TCP连接上，传输数据的基本形式是二进制流（一段一段的1和0）；一般编程语言或网络框架提供的API中，传输数据的基本形式是字节Byte，一个字节是8个二进制位，8个Bit。

**序列化：**将结构化数据转换成字节流的过程；

**反序列化：**将字节流转换成结构化数据的过程；

序列化的用途：

1. 用于在网络上传输数据
2. 将结构化数据保存在文件中

好的序列化实现具备的特点：

1. 序列化后的数据最好是易于人类阅读
1. 实现的复杂度足够低
1. 序列化和反序列化的速度越快越好
1. 序列化后的信息密度越大越好，也就是序列化后占用的存储空间越小越好

实现高性能的序列化与反序列化:

将结构化数据转化成字节流或二进制流

## TCP

报文、帧、数据包等的区别

序号 Sequence Number
TCP用序号对数据包进行标记，便于到达目的地后重新组装；在建立连接时，通常计算机会生成一个随机数作为序列号的初始值，假设当前的序列号为s，发送数据长度为l，下次发送数据时的序列号为s+l。

确认号 Acknowledgemt Number
TCP的可靠性，建立在「每一个数据报文都需要确认收到」的基础之上。通讯的任何一方在收到对方的一个报文之后，都要发送一个相对应的「确认报文」，来表达确认收到。

数据偏移 Offset
指出TCP报文段的首部长度，数据起始处与报文起始处的距离。

标志位 TCP Flag
ACK：确认序号有效
RST：重置连接
SYN：发起一个新连接
FIN：释放一个连接

数据流传送、可靠性、有效流控、全双工操作和多路复用；

主机A向主机B发出连接请求数据包：“我想给你发数据，可以吗？”，这是第一次对话；主机B向主机A发送同意连接和要求同步 （同步就是两台主机一个在发送，一个在接收，协调工作）的数据包：“可以，你什么时候发？”，这是第二次对话；主机A再发出一个数据包确认主机B的要求同 步：“我现在就发，你接着吧！”，这是第三次对话。三次“对话”的目的是使数据包的发送和接收同步，经过三次“对话”之后，主机A才向主机B正式发送数据。

当客户A 没有东西要发送时就要释放 A 这边的连接，A会发送一个报文（没有数据），其中 FIN 设置为1, 服务器B收到后会给应用程序一个信，这时A那边的连接已经关闭，即A不再发送信息（但仍可接收信息）。 A收到B的确认后进入等待状态，等待B请求释放连接， B数据发送完成后就向A请求连接释放，也是用FIN=1 表示， 并且用 ack = u+1(如图）， A收到后回复一个确认信息，并进入 TIME_WAIT 状态， 等待 2MSL 时间。为了这种情况： B向A发送 FIN = 1 的释放连接请求，但这个报文丢失了， A没有接到不会发送确认信息， B 超时会重传，这时A在 WAIT_TIME 还能够接收到这个请求，这时再回复一个确认就行了。（A收到 FIN = 1 的请求后 WAIT_TIME会重新记时）

当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

TCP 负责应用软件（比如你的浏览器）和网络软件之间的通信。
IP 负责计算机之间的通信。
TCP 负责将数据分割并装入 IP 包，然后在它们到达的时候重新组合它们。
IP 负责将包发送至接受者。

SYN攻击：
在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。
# netstat -nap | grep SYN_RECV

TCP连接是全双工的，每个方向上的连接都必须单独进行关闭。
