# 代码风格

## 设计模式

<http://wen.topgoer.com/docs/golang-design-pattern/golang-design-pattern-1cbgha2ltg796>

### 创建型模式

核心思想是方法单一职责，接口的封装和功能的组合

### 简单工厂

将结构体首字母小写不可导出

### 工厂方法

将功能对象生成的方法绑定到子类上，真正的功能方法在积累上；
需要有单独的函数负责调用逻辑；

### 抽象工厂模式

将一组类实现同一个接口，单独函数可以对实现了该接口的所有对象进行操作

### 创建者模式

将对象的创建方法与功能方法分开，将创建方法拆分为多个创建方法，并实现接口，然后组合调用多个创建方法，完成对象的创建。

### 原型模式

原型模式使对象能复制自身，并暴露到接口，使客户端面向接口编程时，不知道接口实际对象的情况下生成新的对象。
原型模式配合原型管理器使用，使客户端在不知道具体类的情况下，通过接口管理器得到新的实例

### 单例模式

使用懒惰模式的单例模式，使用双重检查加锁保证线程安全

### 结构型模式

### 外观模式

? 这是什么意思？门面模式？

### 适配器模式

适配器模式用于转换一种接口适配另一种接口；
具体方法是，利用构造函数，将原接口类型传入，并作为目标接口类型类的成员。
非入侵式接口特征？

### 代理模式

代理模式用于延迟处理操作或进行实际操作前后进行其他处理。
类似于装饰器，在真实功能呢函数外，包裹了一层其他条件检查或判断的逻辑。

### 组合模式

组合模式统一对象和对象集，使用相同接口使用对象和对象集；
组合模式常用于树状结构，统一叶子节点和树节点访问。

### 享元模式

从对象中剥离出不发生改变且多个实例需要的重复数据，独立出一个享元，使多个对象共享，节省内存及减少对象数量。

### 装饰模式

使用对象组合的方式动态改变或增加对象行为
使用匿名组合，装饰器中不必显式定义转调原对象方法；
实现方式：结构体工厂方法使用新的结构体（实现了原接口的方法，这个新结构体的方法会调用旧的结构体方法，在这个新的结构体方法中可以对旧的结构体方法进行功能新增）进行包裹。

### 桥模式

分离抽象部分和实现部分。使两部分独立拓展。
实现方式：将实现部分抽象为结构体的成员，使用工厂方法初始化对象时，将实现部分传入。

### 行为模式

### 中介者模式

封装对象之间互交，使依赖变简单，是复杂交互简单化，封装在中介者中。
利用switch封装转换函数。

### 观察者模式

一个对象的改变会触发其它观察者的相关动作，而此对象无需关心联动对象的具体实现。
实现方式：对象的内部字段有个记录所有观察者的slice，出现数据更新时，就会调用通知方法，通知slice中保存的所有观察者。

### 命令模式

把某个对象的方法调用封装到对象中，方便传递、存储、调用。
将功能封装成结构体，结构体都实现了同一个接口类型，在调用时可以随意切换功能结构体。

### 迭代器模式

用于使用相同方式迭代不同类型集合或者隐藏集合类型的具体实现。

### 模板方法模式

将通用方法和通用步骤放在父类中，把具体实现延迟到子类中时间。

### 策略模式

定义一系列算法，让这些算法在运行时可以切换，使得分离算法。
开闭原则？
结构体嵌套，对调用方法进行封装。

### 状态模式

用于分离状态与行为

### 备忘录模式

保存程序内部状态到外部，不暴露内部实现细节。
实现方式，接口取具体类型。

### 解释器模式

解释器模式定义一套语言文法，并设计该语言解释器，使用户能使用特定文法控制解释器行为。解释器模式的意义在于，它分离多种复杂功能的实现，每个功能只需关注自身的解释。对于调用者不用关心内部的解释器的工作，只需要用简单的方式组合命令就可以。

### 职责链模式

分离不同职责，动态组合相关职责

### 访问者模式

给一系列对象透明的添加功能，把相关代码封装到一个类中。

## 破坏性能的操作

不断的申请新的内存；
